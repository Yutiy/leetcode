---
title: '算法复杂度'
date: 2020-03-26
permalink: 'thinking/complex'
tag:
  - thinking
categories:
  - thinking
---

如何表示算法复杂度，具体来讲就是代码执行的时间、执行消耗的存储空间。例如:

```js
function cal(n) {
  let sum = 0; // 1 unit_time
  let i = 0; // 1 unit_time
  for (; i <= n; i++) {
    // n unit_time
    sum += i; // n unit_time
  }
  return sum;
}
```

从 CPU 的角度看，每段代码其实就是读写数据或操作数据，尽管每次操作 CPU 执行的个数、执行的时间都不同，但可以粗略的把每次执行的时间看作一致，称为 `unit_time`。

所以上述代码总共执行 `(2n+2)*unit_time`, 即 `T(n) = (2n+2)*unit_time`，所以可以写成 `T(n) = O(f(n))`，其中:

- n: 表示数据规模的大小
- f(n): 表示每行代码执行的次数总和
- O: 表示代码的执行时间 T(n) 与 f(n) 表达式成正比

当 n 很大时，`T(n) = O(f(n))` 可以表示为 `T(n) = O(n)`。

这就是**大 O 时间复杂度表示法，大 O 时间复杂度实际上并不具体代码代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势**，所以也叫做**渐进时间复杂度**，简称**时间复杂度**。

## 时间复杂度

当 n 无限大时，时间复杂度 `T(n)` 受 n 的最高数量级影响最大，与 `f(n)` 中的常量、低阶、系数关系不大。所以分析代码的时间复杂度时，只需要关注代码执行次数最多的那段就行了。

举个 🌰:

```js
function fun1(n) {
  let sum = 0,
    i = 0;
  for (; i <= n; i++) {
    sum += i;
  }
  return sum;
}

function fun2(n) {
  let sum = 0,
    sum1 = 0,
    i = 0,
    j = 0;
  for (; i <= n; i++) {
    // 循环1
    sum += i;
  }
  for (i = 0; i <= n; i++) {
    // 循环2
    for (j = 0; j <= n; j++) {
      sum += i * j;
    }
  }
  return sum;
}
function fun3(n) {
  let sum = 0,
    i = 0;
  for (; i <= n; i++) {
    sum += fun(i);
  }
  return sum;
}
```

- `fun1` 中第 1 行都是常量，对 n 的影响不大，所以总的时间复杂度要看第 2、3 行的循环，即时间复杂度为： O(n)
- `fun2` 中循环 1 的时间复杂度为 O(n) ，循环 2 的时间复杂度为 O(n2)，当 n 趋于无穷大时，总体的时间复杂度要趋于 O(n2) ，即上面代码的时间复杂度是 O(n2)
- `fun3` 的时间复杂度是 `O(n * T(fun)) = O(n*n)` ，即 O(n2)

所以: `所以：T(c+n)=O(n)，T(m+n)=O(max(m, n))，T(n) = T1(n) T2(m) = O(nm)，其中 c 为常量`

## 空间复杂度

时间复杂度表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度表示算法的存储空间与数据规模之间的增长关系。例如：

```js
function fun(n) {
  let a = [];
  for (let i = 0; i < n; i++) {
    a.push(i);
  }
  return a;
}
```

以上代码我们可以清晰的看出代码执行的空间为 O(1+n) = O(n)，即为 i 及数组 a 占用的储存空间

## 平均时间复杂度

时间复杂度受数据本身影响，还分为：

- 最好时间复杂度：在最理想的情况下，执行这段代码的时间复杂度
- 最坏时间复杂度：在最糟糕的情况下，执行这段代码的时间复杂度
- 平均时间复杂度：所有情况下，求一个平均值，可以省略掉系数、低阶、常量
